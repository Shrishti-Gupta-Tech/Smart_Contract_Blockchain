# Project Report: Analysis and Mitigation of Smart Contract Vulnerabilities

## Focus: Unchecked Return Values of Low-Level Calls (SWC-104)

**Submitted by:** [Your Name/Student ID]  
**Course:** Blockchain Technology & Smart Contracts  
**Date:** December 6, 2025

---

## Table of Contents

1.  [Chapter 1: Theoretical Foundations](#chapter-1-theoretical-foundations)
    - 1.1 Blockchain and Smart Contracts
    - 1.2 The Ethereum Virtual Machine (EVM) Architecture
    - 1.3 Gas Mechanism and Computational Limits
    - 1.4 The Imperative of Security in Immutable Systems
2.  [Chapter 2: Vulnerability Analysis](#chapter-2-vulnerability-analysis)
    - 2.1 Solidity Call Semantics: High-Level vs. Low-Level
    - 2.2 The `CALL` Opcode Internals
    - 2.3 SWC-104: Unchecked Call Return Value
    - 2.4 Root Causes and Psychological Factors
3.  [Chapter 3: Project Implementation and Design](#chapter-3-project-implementation-and-design)
    - 3.1 System Architecture: The Relayer Pattern
    - 3.2 Vulnerable Contract Design (`Vulnerable.sol`)
    - 3.3 Attack Vector Analysis
    - 3.4 Mitigation Strategy 1: Atomicity Enforcement (`Fix1`)
    - 3.5 Mitigation Strategy 2: Conditional Logic Flow (`Fix2`)
4.  [Chapter 4: Demonstration and Empirical Results](#chapter-4-demonstration-and-empirical-results)
    - 4.1 Experimental Setup
    - 4.2 Vulnerability Reproduction Steps
    - 4.3 Fix Verification and Trace Analysis
5.  [Chapter 5: Deployment and Operational Guide](#chapter-5-deployment-and-operational-guide)
    - 5.1 Deployment Environments
    - 5.2 Method 1: Remix IDE (Browser-Based)
    - 5.3 Method 2: Hardhat (Local & Scripted)
    - 5.4 Method 3: Public Testnets (Sepolia)
6.  [Chapter 6: Conclusion and Future Scope](#chapter-6-conclusion-and-future-scope)

---

## Chapter 1: Theoretical Foundations

### 1.1 Blockchain and Smart Contracts

A **Blockchain** is a distributed, immutable ledger that records transactions across a network of computers. It ensures data integrity through cryptographic hashing and consensus mechanisms (like Proof of Stake).

**Smart Contracts**, a term coined by Nick Szabo in the 1990s, are self-executing programs deployed on a blockchain. Unlike traditional legal contracts, they rely on code to enforce terms.

- **Determinism**: Given the same input and state, a smart contract will always produce the same output.
- **Trustlessness**: Participants do not need to trust each other or a third party; they only need to trust the code and the underlying consensus protocol.

### 1.2 The Ethereum Virtual Machine (EVM) Architecture

Ethereum is the dominant smart contract platform. It runs on the **EVM**, a stack-based virtual machine.

- **Storage**: Persistent data stored on the blockchain (expensive).
- **Memory**: Temporary data exists only during function execution (cheaper).
- **Stack**: A LIFO structure for small local variables and intermediate calculations (cheapest).

The EVM executes **Opcodes** (Operation Codes). Solidity code is compiled down to these opcodes (e.g., `PUSH`, `POP`, `SSTORE`, `CALL`). Understanding vulnerabilities often requires understanding how these opcodes behave at the lowest level.

### 1.3 Gas Mechanism and Computational Limits

The EVM is quasi-Turing-complete. To prevent infinite loops (The Halting Problem) and resource abuse, every operation costs **Gas**.

- **Gas Limit**: The maximum gas a user is willing to spend.
- **Gas Price**: The amount of ETH paid per unit of gas.
  If a transaction runs out of gas, the EVM reverts all state changes, but the miner keeps the fee. This mechanism is crucial for network stability but introduces complexity in error handling.

### 1.4 The Imperative of Security in Immutable Systems

In traditional software (Web2), bugs can be patched with an update. In Web3:

1.  **Immutability**: Code cannot be changed. If a bug is deployed, it is permanent (unless specific upgradeability patterns are used).
2.  **High Stakes**: Contracts often hold millions of dollars in user funds.
3.  **Public Nature**: The source code (or bytecode) is visible to everyone, including attackers.

This "adversarial environment" means security must be proactive, not reactive.

---

## Chapter 2: Vulnerability Analysis

### 2.1 Solidity Call Semantics: High-Level vs. Low-Level

Solidity offers two paradigms for calling external contracts:

1.  **High-Level Calls (Recommended)**:

    - Syntax: `Interface(address).function(args)`
    - Behavior: The compiler inserts checks. If the called function reverts (fails), the calling function **automatically bubbles up the revert**, stopping the entire transaction.
    - Safety: High.

2.  **Low-Level Calls (The Danger Zone)**:
    - Syntax: `address.call(bytes)`
    - Behavior: This maps directly to the `CALL` opcode. It sends raw data to an address.
    - **Crucial Difference**: If the sub-call fails, **it does NOT revert the main execution flow**. Instead, it returns a boolean `false`.

### 2.2 The `CALL` Opcode Internals

The `CALL` opcode in the EVM pushes a boolean onto the stack after execution:

- `1` (True): Execution succeeded.
- `0` (False): Execution failed (revert, panic, or out of gas).

The vulnerability **SWC-104** occurs when the developer ignores this stack value. The EVM simply continues to the next program counter (PC), executing the subsequent instructions as if nothing went wrong.

### 2.3 SWC-104: Unchecked Call Return Value

The Smart Contract Weakness Classification (SWC) Registry defines SWC-104 as "Unchecked Call Return Value".

- **Risk**: State corruption. The contract updates its internal state (e.g., marking an item as "sold") assuming the external call (e.g., "transfer money") succeeded.
- **Impact**: Loss of funds, broken logic, locked assets.

### 2.4 Root Causes and Psychological Factors

Why do developers make this mistake?

1.  **Assumption of Success**: "The token contract is standard; it won't fail."
2.  **Language Confusion**: In many languages (Java, Python), exceptions bubble up automatically. Solidity's low-level calls behave more like C system calls, where you must check return codes.
3.  **Gas Optimization**: Historically, checking return values cost a tiny amount of extra gas, leading some to skip it (a dangerous optimization).

---

## Chapter 3: Project Implementation and Design

### 3.1 System Architecture: The Relayer Pattern

Our project models a "Relayer" system. A Relayer is a common pattern where a contract acts as an intermediary to execute transactions on behalf of a user.

- **User** -> **Relayer Contract** -> **Target Contract**
- The Relayer tracks balances or credits for the user.

### 3.2 Vulnerable Contract Design (`Vulnerable.sol`)

The `VulnerableRelayer` contract contains the flaw:

```solidity
function executeAndCredit(address target, bytes calldata data) external {
    target.call(data); // <--- The Flaw: Return value ignored
    balances[msg.sender] += 100; // <--- State update happens regardless
}
```

This violates the **Check-Effects-Interactions** pattern, or rather, it performs an Interaction without checking its result before applying Effects.

### 3.3 Attack Vector Analysis

An attacker exploits this by providing a `target` address that is programmed to fail.

1.  **Attacker** deploys `RevertingTarget`.
2.  **Attacker** calls `VulnerableRelayer.executeAndCredit(RevertingTarget)`.
3.  **Relayer** calls `RevertingTarget`.
4.  **RevertingTarget** executes `revert()`.
5.  **Relayer** receives `false` from the call but ignores it.
6.  **Relayer** increases Attacker's balance.
7.  **Result**: Attacker gains balance without a successful execution.

### 3.4 Mitigation Strategy 1: Atomicity Enforcement (`Fix1`)

The first fix (`Fix1_CheckedCall.sol`) enforces **Atomicity**. Atomicity means a transaction is "all or nothing".

```solidity
(bool success, ) = target.call(data);
require(success, "Call failed");
```

The `require` function checks the boolean. If false, it executes the `REVERT` opcode. This undoes _all_ changes made in the transaction, including the gas spent (except for the gas used up to that point).

### 3.5 Mitigation Strategy 2: Conditional Logic Flow (`Fix2`)

The second fix (`Fix2_Conditional.sol`) allows for **Partial Failure**.

```solidity
if (success) {
    balances[msg.sender] += 100;
} else {
    emit CallFailed(target);
}
```

This is useful in batch processing. If one request in a batch of 10 fails, you might want the other 9 to succeed. This approach requires careful state management to ensure the failed request doesn't leave the system in an invalid state.

---

## Chapter 4: Demonstration and Empirical Results

### 4.1 Experimental Setup

We utilize two primary environments:

1.  **Remix VM**: A browser-based blockchain simulator. It is fast and provides immediate visual feedback on transaction status and logs.
2.  **Hardhat Network**: A local Ethereum network node designed for development. It allows for scripted testing and console logging.

### 4.2 Vulnerability Reproduction Steps

1.  Deploy `VulnerableRelayer`.
2.  Deploy `RevertingTarget`.
3.  Call `executeAndCredit`.
4.  **Observation**: The transaction status is "Success" (Green checkmark).
5.  **State Check**: `balances(attacker)` is `100`.
6.  **Analysis**: The EVM executed the state update despite the sub-call reverting.

### 4.3 Fix Verification and Trace Analysis

**Testing Fix 1 (`CheckedCall`)**:

- Call `executeAndCredit`.
- **Observation**: Transaction status is "Revert" (Red cross).
- **Error Message**: "Call failed".
- **State Check**: Balance remains `0`.
- **Trace**: The debugger shows execution stopping at the `require` statement.

**Testing Fix 2 (`Conditional`)**:

- Call `executeAndCredit`.
- **Observation**: Transaction status is "Success".
- **Logs**: An event `CallFailed` is emitted.
- **State Check**: Balance remains `0`.
- **Trace**: The debugger shows execution entering the `else` block.

---

## Chapter 5: Deployment and Operational Guide

### 5.1 Deployment Environments

- **Local (Hardhat/Remix VM)**: Used for rapid iteration. No real funds are at risk. Instant confirmation.
- **Testnet (Sepolia/Goerli)**: Public networks that mimic Mainnet. Used for integration testing with other contracts and wallet interfaces (MetaMask). Uses "Test ETH" which has no value.
- **Mainnet**: The live Ethereum network. Real value is at risk. Deployment costs real money.

### 5.2 Method 1: Remix IDE (Browser-Based)

Remix is an "Integrated Development Environment" in the browser.

1.  **Compile**: Converts Solidity to Bytecode.
2.  **Deploy**: Sends a transaction to create the contract instance.
3.  **Interact**: Generates a UI based on the contract's ABI (Application Binary Interface).

### 5.3 Method 2: Hardhat (Local & Scripted)

Hardhat is a development environment for professionals.

- **Scripting**: Allows automating complex deployments (e.g., deploying 5 contracts and linking them).
- **Testing**: Uses Mocha/Chai for automated unit tests.
- **Console.log**: Allows debugging Solidity code from the terminal.

### 5.4 Method 3: Public Testnets (Sepolia)

Deploying to Sepolia requires:

1.  **RPC Provider**: A node provider (like Alchemy or Infura) to broadcast the transaction.
2.  **Private Key**: To sign the transaction.
3.  **Test ETH**: To pay for gas.

---

## Chapter 6: Conclusion and Future Scope

### 6.1 Conclusion

The "Unchecked Return Value" vulnerability serves as a potent reminder of the differences between traditional programming and smart contract engineering. In the EVM, silence does not imply success.

- **Vulnerability**: Ignoring `call` return values leads to state corruption.
- **Mitigation**: Always check `bool success` using `require` or `if`.

This project successfully demonstrated the vulnerability in a controlled environment and verified two distinct architectural patterns for fixing it.

### 6.2 Future Scope

- **Automated Analysis**: Integrating tools like **Slither** or **Mythril** to automatically detect this vulnerability in CI/CD pipelines.
- **Fuzz Testing**: Using **Foundry** to fuzz test the fixes against random inputs to ensure robustness.
- **Formal Verification**: Mathematically proving that the `balances` mapping can never increase if the external call fails.

---

## References

1.  **Solidity Documentation**: [Control Structures & Error Handling](https://docs.soliditylang.org/en/v0.8.20/control-structures.html)
2.  **SWC Registry**: [SWC-104: Unchecked Call Return Value](https://swcregistry.io/docs/SWC-104)
3.  **Ethereum Yellow Paper**: Dr. Gavin Wood. (Defines the formal specification of the EVM).
4.  **ConsenSys Best Practices**: [External Calls](https://consensys.github.io/smart-contract-best-practices/development-recommendations/general/external-calls/)
