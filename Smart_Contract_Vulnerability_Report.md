# Project Report: Analysis and Mitigation of Smart Contract Vulnerabilities

## Focus: Unchecked Return Values of Low-Level Calls

**Submitted by:** [Your Name/Student ID]  
**Course:** Blockchain Technology & Smart Contracts  
**Date:** December 6, 2025

---

## Table of Contents

1.  [Chapter 1: Introduction](#chapter-1-introduction)
    - 1.1 What is a Smart Contract?
    - 1.2 The Ethereum Virtual Machine (EVM)
    - 1.3 The Importance of Smart Contract Security
2.  [Chapter 2: Vulnerability Analysis](#chapter-2-vulnerability-analysis)
    - 2.1 Understanding External Calls in Solidity
    - 2.2 The "Unchecked Return Value" Vulnerability (SWC-104)
    - 2.3 Why This Vulnerability Occurs
3.  [Chapter 3: Project Implementation](#chapter-3-project-implementation)
    - 3.1 Vulnerable Code Design
    - 3.2 Exploit Mechanism
    - 3.3 Proposed Mitigation Strategies
4.  [Chapter 4: Demonstration and Results](#chapter-4-demonstration-and-results)
    - 4.1 Testing Environment
    - 4.2 Verification of Vulnerability
    - 4.3 Verification of Fixes
5.  [Chapter 5: Deployment Guide](#chapter-5-deployment-guide)
    - 5.1 Method 1: Remix IDE
    - 5.2 Method 2: Hardhat Local Node
    - 5.3 Method 3: Testnet Deployment
6.  [Chapter 6: Conclusion](#chapter-6-conclusion)

---

## Chapter 1: Introduction

### 1.1 What is a Smart Contract?

A **Smart Contract** is a self-executing contract with the terms of the agreement between buyer and seller being directly written into lines of code. The code and the agreements contained therein exist across a distributed, decentralized blockchain network.

Key characteristics include:

- **Autonomy**: Once deployed, they run automatically without a central authority.
- **Immutability**: The code cannot be changed once deployed (usually).
- **Transparency**: The logic is visible to all participants on the blockchain.

### 1.2 The Ethereum Virtual Machine (EVM)

Ethereum is the most popular platform for smart contracts. It runs on the **EVM (Ethereum Virtual Machine)**, a quasi-Turing-complete machine that executes the bytecode of smart contracts. Every operation in the EVM requires "Gas," a fee paid in Ether (ETH) to compensate miners/validators for computational resources.

### 1.3 The Importance of Smart Contract Security

Unlike traditional software, smart contracts often hold significant financial value (cryptocurrencies, tokens). A bug in a smart contract can lead to the irreversible loss of millions of dollars. Because contracts are immutable, patching a bug after deployment is often impossible or requires complex upgrade mechanisms. Therefore, identifying and fixing vulnerabilities _before_ deployment is critical.

---

## Chapter 2: Vulnerability Analysis

### 2.1 Understanding External Calls in Solidity

Solidity provides multiple ways for a contract to interact with another contract:

1.  **High-Level Calls**: e.g., `TargetContract(address).functionName()`. These are safe by default because they automatically propagate errors. If the target function fails (reverts), the calling function also reverts.
2.  **Low-Level Calls**: e.g., `address.call(data)`, `address.delegatecall(data)`. These operate at a lower level, sending raw bytes to an address.

### 2.2 The "Unchecked Return Value" Vulnerability (SWC-104)

The vulnerability arises specifically with **low-level calls**.

When `address.call()` is executed:

- It returns a tuple: `(bool success, bytes memory data)`.
- **It does NOT revert automatically** if the called function fails.
- Instead, it simply sets the `success` boolean to `false` and continues execution.

**The Vulnerability:** If a developer uses `.call()` but fails to check the `success` boolean, the contract proceeds as if the call was successful. This can lead to critical state inconsistencies.

### 2.3 Why This Vulnerability Occurs

- **Developer Oversight**: Developers accustomed to high-level calls (or other programming languages) might assume that a failure in a sub-call will crash the main program.
- **Complex Logic**: In complex functions, the return value might be ignored to save gas or simplify code, without realizing the security implications.

---

## Chapter 3: Project Implementation

To demonstrate this vulnerability and its fixes, we developed a set of Solidity smart contracts.

### 3.1 Vulnerable Code Design (`Vulnerable.sol`)

We created a contract named `VulnerableRelayer`. Its purpose is to execute a function on a target contract and then credit a user's balance.

```solidity
function executeAndCredit(address target, bytes calldata data) external {
    // VULNERABLE: Return value is ignored
    target.call(data);

    // The contract assumes success and credits the user
    balances[msg.sender] += 100;
}
```

### 3.2 Exploit Mechanism

An attacker can exploit this by:

1.  Creating a malicious contract (or finding an existing one) that always **reverts** (fails).
2.  Calling `executeAndCredit` with the address of this failing contract.
3.  **Result**: The `.call()` returns `false` (failure), but the `VulnerableRelayer` ignores it and proceeds to `balances[msg.sender] += 100`. The attacker gets "free money" (internal credit) for a failed operation.

### 3.3 Proposed Mitigation Strategies

#### Fix 1: Check-Effects-Interactions (Revert on Failure)

The standard fix is to explicitly check the return value and revert the transaction if it is false.

**Code (`Fix1_CheckedCall.sol`):**

```solidity
(bool success, ) = target.call(data);
require(success, "Call failed"); // Reverts if success is false
balances[msg.sender] += 100;
```

This ensures atomicity: either everything happens, or nothing happens.

#### Fix 2: Conditional Execution (Graceful Handling)

In some cases, we want the transaction to succeed even if the external call fails (e.g., a non-critical notification).

**Code (`Fix2_Conditional.sol`):**

```solidity
(bool success, ) = target.call(data);
if (success) {
    balances[msg.sender] += 100; // Only credit on success
} else {
    emit CallFailed(target); // Log failure, don't revert
}
```

---

## Chapter 4: Demonstration and Results

### 4.1 Testing Environment

- **IDE**: Remix IDE / Hardhat
- **Network**: Local Development Network (Remix VM / Hardhat Network)
- **Compiler**: Solidity 0.8.20

### 4.2 Verification of Vulnerability

We deployed `VulnerableRelayer` and a helper contract `RevertingTarget` (which always fails).

- **Action**: Called `executeAndCredit` targeting `RevertingTarget`.
- **Observation**: The transaction did **not** revert. The `balances` mapping showed the user was credited `100` units.
- **Conclusion**: The vulnerability is confirmed. The contract state was corrupted.

### 4.3 Verification of Fixes

1.  **Fix 1 (`FixedRelayerChecked`)**:

    - **Action**: Called `executeAndCredit` targeting `RevertingTarget`.
    - **Observation**: The transaction **reverted** with error "Call failed".
    - **Conclusion**: The fix effectively prevents the invalid state update.

2.  **Fix 2 (`FixedRelayerConditional`)**:
    - **Action**: Called `executeAndCredit` targeting `RevertingTarget`.
    - **Observation**: The transaction succeeded, but the `balances` mapping remained **0**. An event `CallFailed` was emitted.
    - **Conclusion**: The fix handles the failure gracefully without corrupting state.

---

## Chapter 5: Deployment Guide

This chapter details the steps to deploy and test the contracts.

### 5.1 Method 1: Remix IDE (Recommended)

1.  Open [Remix IDE](https://remix.ethereum.org).
2.  Upload `Vulnerable.sol`, `Fix1_CheckedCall.sol`, and `Fix2_Conditional.sol`.
3.  Compile using Solidity Compiler `0.8.0`.
4.  Deploy `VulnerableRelayer` to the "Remix VM" environment.
5.  Deploy `RevertingTarget` and use its address to test the vulnerability.

### 5.2 Method 2: Hardhat Local Node

1.  Install dependencies: `npm install`
2.  Start local node: `npx hardhat node`
3.  Deploy contracts: `npx hardhat run scripts/deploy.js --network localhost`

### 5.3 Method 3: Testnet Deployment

1.  Configure `.env` with `SEPOLIA_RPC_URL` and `PRIVATE_KEY`.
2.  Deploy to Sepolia: `npx hardhat run scripts/deploy.js --network sepolia`

---

## Chapter 6: Conclusion

The "Unchecked Return Value" vulnerability is a subtle but dangerous flaw in smart contract development. It stems from the specific behavior of low-level calls in the EVM. This project demonstrated that by simply ignoring a boolean return value, a contract can be tricked into performing unauthorized state updates.

We successfully implemented and verified two robust solutions:

1.  **Enforcing success** using `require()`.
2.  **Branching logic** using `if(success)`.

Developers must always handle the return values of low-level primitives to ensure the integrity and security of their decentralized applications.

---

## References

1.  Solidity Documentation: [Control Structures](https://docs.soliditylang.org/en/v0.8.20/control-structures.html)
2.  SWC Registry: [SWC-104](https://swcregistry.io/docs/SWC-104)
3.  Ethereum Smart Contract Best Practices (ConsenSys).
